"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
const prettier_1 = require("prettier");
const utilities_1 = require("../../utilities");
const { group, join, conditionalGroup } = prettier_1.doc.builders;
/** The type of the node implemented in this file */
const NODE_TYPE = 'lambda_expression';
function default_1(path) {
    switch (path.node.type) {
        case NODE_TYPE:
            return printLambdaExpression;
        case 'lambda_bindings':
            return printLambdaBindings;
        case 'lambda_binding':
            return printLambdaBinding;
    }
    return null;
}
/**
 * Print `labda_expression` node.
 * Inside:
 * - `lambda_bindings`
 * - `_bind`
 */
function printLambdaExpression(path, options, print) {
    const children = path.node.nonFormattingChildren;
    // just bindings
    if (children.length === 1) {
        return path.call(print, 'nonFormattingChildren', 0);
    }
    // bindings, expression or bindings, return type
    if (children.length === 2) {
        return join(' ', path.map(print, 'nonFormattingChildren'));
    }
    // bindings, return type, expression
    if (children.length === 3) {
        return [
            path.call(print, 'nonFormattingChildren', 0), // bindings
            ' -> ',
            path.call(print, 'nonFormattingChildren', 1), // return type
            ' ',
            path.call(print, 'nonFormattingChildren', 2), // expression
        ];
    }
    throw new Error('`lambda_expression` node should have 1, 2 or 3 children');
}
/**
 * Print `lambda_bindings` node, contains comma-separated list of `lambda_binding` nodes.
 */
function printLambdaBindings(path, options, print) {
    return group((0, utilities_1.list)({ path, print, options, open: '|', close: '|' }));
}
/**
 * Print `lambda_binding` node.
 * It can be either type annotated or just a variable binding, we know it by the number
 * of non-formatting children.
 */
function printLambdaBinding(path, options, print) {
    // simple bind, will be handled by its function
    if (path.node.nonFormattingChildren.length === 1) {
        return path.call(print, 'nonFormattingChildren', 0);
    }
    // with type annotation
    if (path.node.nonFormattingChildren.length === 2) {
        return join(': ', path.map(print, 'nonFormattingChildren'));
    }
    throw new Error('`lambda_binding` node should have 1 or 2 children');
}
//# sourceMappingURL=lambda_expression.js.map