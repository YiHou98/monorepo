"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.NODE_TYPE = void 0;
exports.default = default_1;
const prettier_1 = require("prettier");
const utilities_1 = require("../utilities");
const VectorExpression = require("./expression/vector_expression");
const block_1 = require("./expression/block");
const { line, group, join, fill, ifBreak, softline, indent, lineSuffix } = prettier_1.doc.builders;
/** The type of the node implemented in this file */
exports.NODE_TYPE = 'constant';
/**
 * Prints:
 * - `constant`
 * - `constant_identifier`
 */
function default_1(path) {
    if (path.node.type === exports.NODE_TYPE) {
        return printConstant;
    }
    else if (path.node.type === 'constant_identifier') {
        return utilities_1.printIdentifier;
    }
    return null;
}
/**
 * Print `constant` node.
 *
 * See `module-members/constant.move` for tests.
 */
function printConstant(path, options, print) {
    const expression = path.node.nonFormattingChildren[2];
    const trailing = lineSuffix((0, utilities_1.printTrailingComment)(path));
    path.node.disableTrailingComment();
    const printCb = (path) => printConstExpression(path, options, print);
    const groupId = Symbol('type_group');
    if (path.node.nonFormattingChildren.length !== 3) {
        throw new Error('`constant` expects 3 children');
    }
    const [identDoc, typeDoc, exprDoc] = path.map(printCb, 'nonFormattingChildren');
    const parts = [];
    // const <ident> : <type> = <expr>;
    parts.push('const ', identDoc);
    parts.push(': ', group(typeDoc, { id: groupId }), ' =');
    if (expression?.isList) {
        parts.push(group([
            ifBreak(indent(line), ' ', { groupId }),
            ifBreak(indent(exprDoc), exprDoc, { groupId }),
        ]));
    }
    else {
        parts.push(group([indent(line), indent(exprDoc)]));
    }
    return parts.concat([';', trailing]);
}
// Sub-router for expressions in the const declaration. Special cases are:
//
// - for vectors with `num` and `bool` literals, we want to fill single line
// - for blocks we want breakability
function printConstExpression(path, options, print) {
    if (path.node.type === VectorExpression.NODE_TYPE) {
        return prettyNumVector(path, options, print);
    }
    if (path.node.type === 'block') {
        return (0, block_1.printBreakableBlock)(path, options, print);
    }
    return print(path);
}
// TODO: optionally move this to `VectorExpression`
function prettyNumVector(path, options, print) {
    let elType = path.node.nonFormattingChildren[0]?.type;
    if (elType && ['num_literal', 'bool_literal'].includes(elType)) {
        let allSameType = !path.node.nonFormattingChildren.some((e) => e.type !== elType);
        let hasComments = path.node.namedChildren.some((e) => e.trailingComment || e.leadingComment.length > 0);
        if (allSameType && !hasComments) {
            const literals = path.map(print, 'nonFormattingChildren');
            if (literals.length == 0) {
                return 'vector[]';
            }
            const elements = join([',', line], literals);
            return [
                'vector[',
                group([indent(softline), indent(fill(elements)), ifBreak(','), softline]),
                ']',
            ];
        }
    }
    return print(path);
}
//# sourceMappingURL=constant.js.map