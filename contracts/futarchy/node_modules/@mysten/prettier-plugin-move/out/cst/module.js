"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Module = void 0;
exports.default = default_1;
exports.printModuleDefinition = printModuleDefinition;
const prettier_1 = require("prettier");
const function_definition_1 = require("./function_definition");
const struct_definition_1 = require("./struct_definition");
const Constant = require("./constant");
const use_declaration_1 = require("./use_declaration");
const imports_grouping_1 = require("../imports-grouping");
const enum_definition_1 = require("./enum_definition");
const utilities_1 = require("../utilities");
const { join, hardline, indent } = prettier_1.doc.builders;
/**
 * Creates a callback function to print modules and module-related nodes.
 */
function default_1(path) {
    switch (path.node.type) {
        case Module.ModuleDefinition:
            return printModuleDefinition;
        case Module.ModuleIdentity:
            return printModuleIdentity;
        case Module.ModuleIdentifier:
            return utilities_1.printIdentifier;
        case Module.ModuleBody:
            return printModuleBody;
        default:
            return null;
    }
}
/**
 * Module - top-level definition in a Move source file.
 */
var Module;
(function (Module) {
    Module["ModuleDefinition"] = "module_definition";
    Module["BlockComment"] = "block_comment";
    Module["ModuleIdentity"] = "module_identity";
    Module["ModuleIdentifier"] = "module_identifier";
    Module["ModuleBody"] = "module_body";
})(Module || (exports.Module = Module = {}));
/**
 * Print `module_definition` node.
 */
function printModuleDefinition(path, options, print) {
    let useLabel = false;
    // when option is present we must check that there's only one module per file
    if (options.useModuleLabel) {
        const modules = path.parent.nonFormattingChildren.filter((node) => node.type === path.node.type);
        useLabel = modules.length == 1;
    }
    const result = ['module ', path.call(print, 'nonFormattingChildren', 0)];
    // if we're using the label, we must add a semicolon and print the body in a
    // new line
    if (useLabel) {
        return result.concat([
            ';',
            hardline,
            hardline,
            path.call(print, 'nonFormattingChildren', 1),
        ]);
    }
    // when not module mabel, module body is a block with curly braces and
    // indentation
    return result.concat([
        ' {',
        indent(hardline),
        indent(path.call(print, 'nonFormattingChildren', 1)),
        hardline,
        '}',
    ]);
}
/**
 * Print `module_identity` node.
 */
function printModuleIdentity(path, options, print) {
    return join('::', path.map(print, 'nonFormattingChildren'));
}
/**
 * Members that must be separated by an empty line if they are next to each other.
 * For example, a function definition followed by a struct definition.
 */
const separatedMembers = [
    function_definition_1.FunctionDefinition.FunctionDefinition,
    struct_definition_1.StructDefinition.StructDefinition,
    Constant.NODE_TYPE,
    use_declaration_1.UseDeclaration.UseDeclaration,
    use_declaration_1.UseDeclaration.FriendDeclaration,
    enum_definition_1.EnumDefinition.EnumDefinition,
];
/**
 * Print `module_body` node.
 *
 * We need to preserve spacing between members (functions, structs, constants, etc.).
 * We need to only allow a single empty line (if there are more than one, we should remove them).
 * Additionally, if `groupImports` is set to `package` or `module`, we should group imports and
 * print them at the top of the module.
 */
function printModuleBody(path, options, print) {
    const nodes = path.node.namedAndEmptyLineChildren;
    const importsDoc = [];
    const imports = (0, imports_grouping_1.collectImports)(path.node);
    if (imports.size > 0) {
        importsDoc.push(...(0, imports_grouping_1.printImports)(imports, options.autoGroupImports));
    }
    const bodyDoc = [];
    path.each((path, i) => {
        const next = nodes[i + 1];
        // empty lines should be removed if they are next to grouped imports
        if (path.node.isEmptyLine && path.node.previousNamedSibling?.isGroupedImport)
            return;
        if (path.node.isGroupedImport)
            return;
        if (path.node.isEmptyLine && !path.node.previousNamedSibling)
            return;
        if (separatedMembers.includes(path.node.type) &&
            separatedMembers.includes(next?.type || '') &&
            path.node.type !== next?.type) {
            return bodyDoc.push([path.call(print), hardline]);
        }
        // force add empty line after function definitions
        if (path.node.type === function_definition_1.FunctionDefinition.FunctionDefinition &&
            next?.type === function_definition_1.FunctionDefinition.FunctionDefinition) {
            return bodyDoc.push([path.call(print), hardline]);
        }
        return bodyDoc.push(path.call(print));
    }, 'namedAndEmptyLineChildren');
    if (bodyDoc.length > 0 && importsDoc.length > 0) {
        bodyDoc.unshift(''); // add empty line before first member
    }
    return join(hardline, importsDoc.concat(bodyDoc));
}
//# sourceMappingURL=module.js.map