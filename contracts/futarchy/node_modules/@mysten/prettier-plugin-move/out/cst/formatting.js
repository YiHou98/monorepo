"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatting = void 0;
exports.default = default_1;
exports.startsOnNewLine = startsOnNewLine;
exports.shouldNewLine = shouldNewLine;
exports.isFormatting = isFormatting;
exports.isComment = isComment;
exports.isEmptyLine = isEmptyLine;
exports.isNewline = isNewline;
exports.printLineComment = printLineComment;
exports.printBlockComment = printBlockComment;
exports.printEmptyLine = printEmptyLine;
exports.printNewline = printNewline;
/**
 * Creates a callback function to print commments and comment-related nodes.
 *
 * @param path
 * @returns
 */
function default_1(path) {
    switch (path.node.type) {
        case Formatting.LineComment:
            return printLineComment;
        case Formatting.BlockComment:
            return printBlockComment;
        case Formatting.EmptyLine:
            return printEmptyLine;
        case Formatting.Newline:
            return printNewline;
        default:
            return null;
    }
}
var Formatting;
(function (Formatting) {
    Formatting["LineComment"] = "line_comment";
    Formatting["BlockComment"] = "block_comment";
    /**
     * Token that doesn't exist in the grammar but we insert it in
     * the `Tree` representation of CST to represent an empty line.
     */
    Formatting["EmptyLine"] = "empty_line";
    /**
     * Special node to insert a newline before the next node.
     * We use it to make a call to hardline or not.
     */
    Formatting["Newline"] = "newline";
})(Formatting || (exports.Formatting = Formatting = {}));
function startsOnNewLine(path) {
    return path.previous?.type == Formatting.EmptyLine;
}
function shouldNewLine(path) {
    return path.node.nextNamedSibling?.type == Formatting.Newline;
}
/**
 * Test if a node is a formatting node.
 *
 * @param node
 * @returns
 */
function isFormatting(node) {
    return [
        Formatting.LineComment,
        Formatting.BlockComment,
        Formatting.EmptyLine,
        Formatting.Newline,
    ].includes(node.type);
}
function isComment(node) {
    return [Formatting.LineComment, Formatting.BlockComment].includes(node?.type);
}
function isEmptyLine(node) {
    return Formatting.EmptyLine == node?.type;
}
function isNewline(node) {
    return Formatting.Newline == node?.type;
}
/**
 * Print `line_comment` node.
 * Comments are handled via the `addLeadingComments` function.
 */
function printLineComment(path) {
    return path.node.text;
}
/**
 * Print `block_comment` node.
 */
function printBlockComment(path) {
    return path.node.text;
}
function printEmptyLine(path) {
    return ''; // should not be printed directly, used in `join(hardline)` to act as an extra newline
}
function printNewline(path) {
    return ''; // should not be printed, ever
}
//# sourceMappingURL=formatting.js.map