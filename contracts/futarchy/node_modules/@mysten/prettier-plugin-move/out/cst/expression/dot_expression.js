"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.NODE_TYPE = void 0;
exports.default = default_1;
const prettier_1 = require("prettier");
const utilities_1 = require("../../utilities");
const { group, indent, ifBreak, breakParent, lineSuffix, softline } = prettier_1.doc.builders;
/** The type of the node implemented in this file */
exports.NODE_TYPE = 'dot_expression';
function default_1(path) {
    if (path.node.type === exports.NODE_TYPE) {
        return printDotExpression;
    }
    return null;
}
/**
 * Print `dot_expression` node.
 *
 * Note, that it's intentional, that the return value is not a `group`. For more info,
 * @see [This Issue](https://github.com/prettier/prettier/issues/15710#issuecomment-1836701758)
 */
function printDotExpression(path, options, print) {
    if (path.node.nonFormattingChildren.length < 2) {
        throw new Error('`dot_expression` node should have at least 2 children');
    }
    // chain is a `dot_expression` that is a child of another `dot_expression`
    // or which has a `dot_expression` as a child
    const isChain = path.node.nonFormattingChildren[0].type === exports.NODE_TYPE ||
        path.node.parent?.type === exports.NODE_TYPE;
    const isParentList = path.node.parent?.isList;
    // if dot expression has a trailing comment and it breaks, we need to
    // print it manually after the rhs
    const trailing = lineSuffix((0, utilities_1.printTrailingComment)(path));
    const lhs = path.call((path) => printNode(path, options, print, false), 'nonFormattingChildren', 0);
    const rhs = path.call((path) => printNode(path, options, print, true), 'nonFormattingChildren', 1);
    // if it's a single expression, we don't need to group it
    // and optionally no need to break it; no need to special
    // print it in this case
    if (!isChain) {
        const right = path.node.nonFormattingChildren[1];
        if (right.leadingComment.length > 0) {
            path.node.disableTrailingComment();
            return [lhs, indent(softline), indent(rhs), trailing];
        }
        return [lhs, rhs];
    }
    path.node.disableTrailingComment();
    const parts = [lhs, ifBreak(indent(softline), ''), ifBreak(indent(rhs), rhs), trailing];
    // group if parent is not `dot_expression`
    if (isChain && path.node.parent?.type !== exports.NODE_TYPE) {
        return group(parts);
    }
    return parts;
}
// In `dot_expression` we need to keep the `.` in the same line as the `rhs`,
// so we need to prevent automatic printing of comments in the `print` call, and
// perform it manually.
function printNode(path, options, print, insertDot = false) {
    const leading = (0, utilities_1.printLeadingComment)(path, options);
    const shouldBreak = path.node.leadingComment.length > 0 || path.node.trailingComment?.type === 'line_comment';
    path.node.disableLeadingComment();
    return [leading, shouldBreak ? breakParent : '', insertDot ? '.' : '', print(path)];
}
//# sourceMappingURL=dot_expression.js.map