"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Common = void 0;
exports.default = default_1;
exports.printPrimitiveType = printPrimitiveType;
exports.printModuleAccess = printModuleAccess;
exports.printRefType = printRefType;
exports.printAbility = printAbility;
exports.printTupleType = printTupleType;
exports.printAlias = printAlias;
const prettier_1 = require("prettier");
const utilities_1 = require("../utilities");
const { group, join, line, indent, hardline } = prettier_1.doc.builders;
/**
 * Creates a callback function to print common nodes.
 */
function default_1(path) {
    switch (path.node.type) {
        case Common.PrimitiveType:
            return printPrimitiveType;
        case Common.ModuleAccess:
            return printModuleAccess;
        // identifiers
        case Common.Identifier:
        case Common.FieldIdentifier:
        case Common.VariableIdentifier:
            return utilities_1.printIdentifier;
        case Common.RefType:
            return printRefType;
        case Common.FunctionType:
            return printFunctionType;
        case Common.FunctionTypeParameters:
            return printFunctionTypeParameters;
        case Common.Ability:
            return printAbility;
        case Common.TupleType:
            return printTupleType;
        // === Bindings ===
        case Common.BindUnpack:
            return printBindUnpack;
        case Common.BindFields:
            return printBindFields;
        case Common.MutBindField:
            return printMutBindField;
        case Common.BindField:
            return printBindField;
        case Common.BindList:
            return printBindList;
        case Common.CommaBindList:
            return printCommaBindList;
        case Common.OrBindList:
            return printOrBindList;
        case Common.AtBind:
            return printAtBind;
        case Common.BindNamedFields:
            return printBindNamedFields;
        case Common.BindPositionalFields:
            return printBindPositionalFields;
        case Common.BindVar:
            return printBindVar;
        case Common.MutBindVar:
            return printMutBindVar;
        case Common.ImmRef:
            return printImmRef;
        case Common.MutRef:
            return printMutRef;
        case Common.Label:
            return printLabel;
        case Common.Alias:
            return printAlias;
        case Common.BlockIdentifier:
            return printBlockIdentifier;
        case Common.UnaryOperator:
            return printUnaryOperator;
        case Common.FieldInitializeList:
            return printFieldInitializeList;
        case Common.ExpressionField:
            return printExpressionField;
        case Common.ArgList:
            return printArgList;
    }
    return null;
}
/**
 * Nodes which are used across multiple files, yet can't be categorized.
 */
var Common;
(function (Common) {
    Common["PrimitiveType"] = "primitive_type";
    Common["VariableIdentifier"] = "variable_identifier";
    Common["ModuleAccess"] = "module_access";
    Common["Identifier"] = "identifier";
    Common["RefType"] = "ref_type";
    Common["FunctionType"] = "function_type";
    Common["FunctionTypeParameters"] = "function_type_parameters";
    Common["FieldIdentifier"] = "field_identifier";
    Common["BlockIdentifier"] = "block_identifier";
    Common["Ability"] = "ability";
    Common["TupleType"] = "tuple_type";
    // === Bindings ===
    Common["BindUnpack"] = "bind_unpack";
    Common["BindFields"] = "bind_fields";
    Common["MutBindField"] = "mut_bind_field";
    Common["BindField"] = "bind_field";
    Common["BindList"] = "bind_list";
    Common["BindNamedFields"] = "bind_named_fields";
    Common["CommaBindList"] = "comma_bind_list";
    Common["OrBindList"] = "or_bind_list";
    Common["AtBind"] = "at_bind";
    Common["BindPositionalFields"] = "bind_positional_fields";
    Common["BindVar"] = "bind_var";
    Common["MutBindVar"] = "mut_bind_var";
    Common["ImmRef"] = "imm_ref";
    Common["MutRef"] = "mut_ref";
    Common["Label"] = "label";
    Common["Alias"] = "alias";
    Common["UnaryOperator"] = "unary_op";
    Common["FieldInitializeList"] = "field_initialize_list";
    Common["ExpressionField"] = "exp_field";
    // used in `call_expression` and `macro_call_expression`
    Common["ArgList"] = "arg_list";
})(Common || (exports.Common = Common = {}));
/**
 * Print `primitive_type` node.
 */
function printPrimitiveType(path, _opt, _p) {
    return path.node.text;
}
/**
 * Print `module_access` node.
 */
function printModuleAccess(path, _opt, print) {
    return path.map(print, 'children');
}
/**
 * Print `ref_type` node.
 */
function printRefType(path, _opt, print) {
    return group([
        path.call(print, 'nonFormattingChildren', 0), // ref_type
        path.call(print, 'nonFormattingChildren', 1), // type
    ]);
}
/**
 * Print `arg_list` node.
 */
function printArgList(path, options, print) {
    const nodes = path.node.nonFormattingChildren;
    if (nodes.length === 1 && nodes[0].isBreakableExpression) {
        const child = nodes[0];
        const shouldBreak = nodes[0]?.trailingComment?.type === 'line_comment' ||
            nodes[0]?.leadingComment.some((e) => e.type === 'line_comment');
        if (shouldBreak) {
            return [
                '(',
                indent(hardline),
                indent(path.call(print, 'nonFormattingChildren', 0)),
                hardline,
                ')',
            ];
        }
        return ['(', path.call(print, 'nonFormattingChildren', 0), ')'];
    }
    return group((0, utilities_1.list)({ path, print, options, open: '(', close: ')' }), {
        shouldBreak: (0, utilities_1.shouldBreakFirstChild)(path),
    });
}
/**
 * Print `ability` node.
 */
function printAbility(path, _opt, _p) {
    return path.node.text;
}
/**
 * Print `tuple_type` node.
 */
function printTupleType(path, options, print) {
    return group((0, utilities_1.list)({
        path,
        print,
        options,
        open: '(',
        close: ')',
        shouldBreak: false,
    }));
}
// === Bindings ===
/**
 * Print `bind_unpack` node.
 * For easier seach: `unpack_expression`.
 *
 * Inside:
 * - `bind_var`
 * - `bind_fields`
 * - `bind_fields`
 *
 * `let Struct { field1, field2 } = ...;`
 */
function printBindUnpack(path, _opt, print) {
    return path.map(print, 'nonFormattingChildren');
}
/**
 * Print `bind_fields` node.
 * Choice node between `bind_named_fields` and `bind_positional_fields`.
 */
function printBindFields(path, _opt, print) {
    return path.call(print, 'nonFormattingChildren', 0);
}
/**
 * Print `bind_field` node.
 */
function printBindField(path, _opt, print) {
    // special case for `..` operator
    if (path.node.child(0)?.type == '..') {
        return '..';
    }
    // if there's only one child, we can just print it
    // if there're two, they will be joined
    return join(': ', path.map(print, 'nonFormattingChildren'));
}
/**
 * Print `mut_bind_field` node.
 */
function printMutBindField(path, _opt, print) {
    return ['mut ', path.call(print, 'nonFormattingChildren', 0)];
}
/**
 * Print `bind_list` node.
 * In the bind list we have two paths:
 *
 * - one is just `bind_var` with potential `mut`
 * - another is a list, and we know it because the first member is `(`.
 */
function printBindList(path, options, print) {
    if (path.node.nonFormattingChildren.length == 1) {
        return join(' ', path.map(print, 'nonFormattingChildren'));
    }
    return group((0, utilities_1.list)({ path, print, options, open: '(', close: ')' }));
}
/**
 * Print `comma_bind_list` node.
 */
function printCommaBindList(path, options, print) {
    return group((0, utilities_1.list)({ path, print, options, open: '(', close: ')' }));
}
/**
 * Print `at_bind` node.
 */
function printAtBind(path, _opt, print) {
    return join(' @ ', path.map(print, 'nonFormattingChildren'));
}
/**
 * Print `or_bind_list` node.
 */
function printOrBindList(path, options, print) {
    return group(join([' |', line], path.map(print, 'nonFormattingChildren')));
}
/**
 * Print `bind_named_fields` node.
 */
function printBindNamedFields(path, options, print) {
    return [
        ' ',
        group((0, utilities_1.list)({ path, print, options, open: '{', close: '}', addWhitespace: true }), {
            shouldBreak: (0, utilities_1.shouldBreakFirstChild)(path),
        }),
    ];
}
/**
 * Print `bind_positional_fields` node.
 */
function printBindPositionalFields(path, options, print) {
    return group((0, utilities_1.list)({ path, print, options, open: '(', close: ')' }), {
        shouldBreak: (0, utilities_1.shouldBreakFirstChild)(path),
    });
}
/**
 * Print `bind_var` node.
 */
function printBindVar(path, _opt, print) {
    return path.call(print, 'nonFormattingChildren', 0);
}
/**
 * Print `mut_bind_var` node.
 */
function printMutBindVar(path, _opt, print) {
    return ['mut ', path.call(print, 'nonFormattingChildren', 0)];
}
/**
 * Print `imm_ref` node.
 */
function printImmRef(path, _opt, print) {
    return '&';
}
/**
 * Print `mut_ref` node.
 */
function printMutRef(path, _opt, print) {
    return '&mut ';
}
/**
 * Print `alias` node. ...as `identifier`
 */
function printAlias(path, _opt, print) {
    return ['as ', path.call(print, 'nonFormattingChildren', 0)];
}
/**
 * Print `block_identifier` node.
 */
function printBlockIdentifier(path, _opt, print) {
    return path.call(print, 'nonFormattingChildren', 0);
}
/**
 * Print `label` node.
 */
function printLabel(path, _opt, _p) {
    if (path.node.nextSibling?.type == ':') {
        return [path.node.text, ':'];
    }
    return path.node.text;
}
/**
 * Print `unary_op` node.
 */
function printUnaryOperator(path, _opt, _p) {
    return path.node.text;
}
/**
 * Print `field_initialize_list` node.
 */
function printFieldInitializeList(path, options, print) {
    return [
        ' ',
        group((0, utilities_1.list)({ path, print, options, open: '{', close: '}', addWhitespace: true }), {
            shouldBreak: (0, utilities_1.shouldBreakFirstChild)(path),
        }),
    ];
}
/**
 * Print `expression_field` node.
 * Inside:
 * - `field_identifier`
 * - `expression`
 */
function printExpressionField(path, _opt, print) {
    const children = path.map(print, 'nonFormattingChildren');
    if (children.length === 1) {
        return children[0];
    }
    return group([children[0], ': ', children[1]]);
}
/**
 * Print `function_type` node.
 * Inside:
 * - `function_type_parameters`
 * - `return_type`
 */
function printFunctionType(path, _opt, print) {
    const children = path.map(print, 'nonFormattingChildren');
    if (children.length === 0) {
        return '||';
    }
    if (children.length === 1) {
        return children[0];
    }
    return join(' -> ', children);
}
/**
 * Print `function_type_parameters` node.
 */
function printFunctionTypeParameters(path, options, print) {
    return group((0, utilities_1.list)({ path, print, options, open: '|', close: '|' }));
}
//# sourceMappingURL=common.js.map