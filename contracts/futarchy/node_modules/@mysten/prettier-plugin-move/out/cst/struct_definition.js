"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructDefinition = void 0;
exports.default = default_1;
exports.printNativeStructDefinition = printNativeStructDefinition;
exports.printStructDefinition = printStructDefinition;
exports.printAbilityDeclarations = printAbilityDeclarations;
exports.printPostfixAbilityDeclarations = printPostfixAbilityDeclarations;
exports.printDatatypeFields = printDatatypeFields;
exports.printNamedFields = printNamedFields;
exports.printPositionalFields = printPositionalFields;
exports.printFieldAnnotation = printFieldAnnotation;
exports.printApplyType = printApplyType;
const prettier_1 = require("prettier");
const utilities_1 = require("../utilities");
const { group, join } = prettier_1.doc.builders;
function default_1(path) {
    switch (path.node.type) {
        case StructDefinition.StructDefinition:
            return printStructDefinition;
        case StructDefinition.NativeStructDefinition:
            return printNativeStructDefinition;
        case StructDefinition.AbilityDeclarations:
            return printAbilityDeclarations;
        case StructDefinition.PostfixAbilityDeclarations:
            return printPostfixAbilityDeclarations;
        case StructDefinition.DatatypeFields:
            return printDatatypeFields;
        case StructDefinition.NamedFields:
            return printNamedFields;
        case StructDefinition.PositionalFields:
            return printPositionalFields;
        case StructDefinition.FieldAnnotation:
            return printFieldAnnotation;
        case StructDefinition.ApplyType:
            return printApplyType;
        case StructDefinition.StructIdentifier:
            return utilities_1.printIdentifier;
    }
    return null;
}
var StructDefinition;
(function (StructDefinition) {
    /**
     * Module-level definition
     * ```
     * public struct identifier ...
     * ```
     */
    StructDefinition["StructDefinition"] = "struct_definition";
    /**
     * Module-level definition (features `native` keyword and has no fields)
     * ```
     * native struct identifier ... ;
     * ```
     */
    StructDefinition["NativeStructDefinition"] = "native_struct_definition";
    StructDefinition["AbilityDeclarations"] = "ability_decls";
    /**
     * Postfix ability declarations must be printed after the fields
     * and be followed by a semicolon.
     * ```
     * struct ident {} has store;
     * struct Point(u8) has store, drop;
     * ```
     */
    StructDefinition["PostfixAbilityDeclarations"] = "postfix_ability_decls";
    StructDefinition["DatatypeFields"] = "datatype_fields";
    StructDefinition["NamedFields"] = "named_fields";
    StructDefinition["PositionalFields"] = "positional_fields";
    StructDefinition["FieldAnnotation"] = "field_annotation";
    StructDefinition["ApplyType"] = "apply_type";
    StructDefinition["StructIdentifier"] = "struct_identifier";
})(StructDefinition || (exports.StructDefinition = StructDefinition = {}));
/**
 * Print `struct_definition` node.
 */
function printNativeStructDefinition(path, options, print) {
    const isPublic = path.node.child(0).type === 'public' ? ['public', ' '] : [];
    return group([
        ...isPublic, // insert `public` keyword if present
        'native',
        ' ',
        'struct',
        ' ',
        path.map(print, 'nonFormattingChildren'),
        ';',
    ]);
}
/**
 * Print `struct_definition` node.
 * Insert a newline before the comment if the previous node is not a line comment.
 */
function printStructDefinition(path, options, print) {
    const isPublic = path.node.child(0).type === 'public' ? ['public', ' '] : [];
    return group([
        ...isPublic, // insert `public` keyword if present
        'struct',
        ' ',
        path.map(print, 'nonFormattingChildren'),
    ]);
}
/**
 * Print `ability_decls` node.
 */
function printAbilityDeclarations(path, options, print) {
    const abilities = formatAndSortAbilities(path, options, print);
    return [
        ' has ',
        join(', ', abilities.map((ability) => ability.text)),
        path.next?.namedChildren[0]?.type === StructDefinition.PositionalFields ? ' ' : '',
    ];
}
/**
 * Print `postfix_ability_decls` node.
 */
function printPostfixAbilityDeclarations(path, options, print) {
    const abilities = formatAndSortAbilities(path, options, print);
    return group([
        ' has ',
        join(', ', abilities.map((ability) => ability.text)),
        ';',
    ]);
}
/**
 * Print `datatype_fields` node.
 * Prints the underlying fields of a datatype.
 */
function printDatatypeFields(path, options, print) {
    return path.map(print, 'nonFormattingChildren');
}
/**
 * Print `named_fields` node.
 * Prints the underlying fields of a struct.
 */
function printNamedFields(path, options, print) {
    const children = path.map(print, 'nonFormattingChildren');
    if (children.length === 0) {
        return [' ', (0, utilities_1.emptyBlockOrList)(path, '{', '}', prettier_1.doc.builders.line)];
    }
    return [
        ' ',
        group((0, utilities_1.list)({ path, print, options, open: '{', close: '}', addWhitespace: true }), {
            shouldBreak: (0, utilities_1.shouldBreakFirstChild)(path),
        }),
    ];
}
/**
 * Print `positional_fields` node.
 * Prints the underlying fields of a struct.
 */
function printPositionalFields(path, options, print) {
    const children = path.map(print, 'nonFormattingChildren');
    if (children.length === 0) {
        return (0, utilities_1.emptyBlockOrList)(path, '(', ')', prettier_1.doc.builders.line);
    }
    return group((0, utilities_1.list)({ path, print, options, open: '(', close: ')' }), {
        shouldBreak: false,
    });
}
/**
 * Print `field_annotation` node.
 */
function printFieldAnnotation(path, options, print) {
    return group([
        path.call(print, 'nonFormattingChildren', 0), // field_identifier
        ':',
        ' ',
        path.call(print, 'nonFormattingChildren', 1), // type
    ]);
}
/**
 * Print `apply_type` node.
 */
function printApplyType(path, options, print) {
    return path.map(print, 'nonFormattingChildren');
}
/**
 * Utility function which formats and sorts abilities in the following order::
 *
 * - key
 * - copy
 * - drop
 * - store
 *
 * Key always goes first, the rest are sorted alphabetically.
 */
function formatAndSortAbilities(path, options, print) {
    const abilities = path.map((path) => ({
        name: path.node.text,
        text: [
            (0, utilities_1.printLeadingComment)(path, options),
            path.node.text,
            (0, utilities_1.printTrailingComment)(path, true),
        ],
    }), 'nonFormattingChildren');
    // alphabetical but `key` always goes first
    const priority = {
        key: 0,
        copy: 1,
        drop: 2,
        store: 3,
    };
    abilities.sort((a, b) => priority[a.name] - priority[b.name]);
    return abilities;
}
//# sourceMappingURL=struct_definition.js.map