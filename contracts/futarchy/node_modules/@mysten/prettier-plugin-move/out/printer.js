"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = print;
const common_1 = require("./cst/common");
const formatting_1 = require("./cst/formatting");
const module_1 = require("./cst/module");
const use_declaration_1 = require("./cst/use_declaration");
const constant_1 = require("./cst/constant");
const struct_definition_1 = require("./cst/struct_definition");
const function_definition_1 = require("./cst/function_definition");
const source_file_1 = require("./cst/source_file");
const expression_1 = require("./cst/expression");
const literal_1 = require("./cst/literal");
const utilities_1 = require("./utilities");
const enum_definition_1 = require("./cst/enum_definition");
const annotation_1 = require("./cst/annotation");
/**
 * Print the AST node at the given path.
 */
function print(path, options, print) {
    // check if the node has an error child, if so, we throw an error or return the error text
    const checkErrorsCb = (path) => {
        if (path.node.children.some((n) => n.type === 'ERROR')) {
            if (options.enableErrorDebug) {
                return ((path, options, print) => ['/* ERROR: */', path.node.text]);
            }
            else {
                throw new Error('tree-sitter failure on \n```\n' + path.node.text + '\n```');
            }
        }
        if (path.node.children.some((n) => n.type === 'MISSING')) {
            if (options.enableErrorDebug) {
                return ((path, options, print) => ['/* MISSING: */', path.node.text]);
            }
            else {
                throw new Error('tree-sitter failure on \n```\n' + path.node.text + '\n```');
            }
        }
        return null;
    };
    // for unimplemented / not yet implemented nodes, we just return the node type
    const defautCb = (path, options, print) => {
        return path.node.type;
    };
    const fn = checkErrorsCb(path) ||
        (0, source_file_1.default)(path) ||
        (0, annotation_1.default)(path) ||
        (0, formatting_1.default)(path) ||
        (0, common_1.default)(path) ||
        (0, module_1.default)(path) ||
        (0, use_declaration_1.default)(path) ||
        (0, constant_1.default)(path) ||
        (0, enum_definition_1.default)(path) ||
        (0, struct_definition_1.default)(path) ||
        (0, function_definition_1.default)(path) ||
        (0, expression_1.default)(path) ||
        (0, literal_1.default)(path) ||
        defautCb;
    return [
        (0, utilities_1.printLeadingComment)(path, options),
        // if the node has a `skipFormattingNode` property, we just return
        // the text without formatting it
        path.node.skipFormattingNode ? path.node.text : fn(path, options, print),
        (0, utilities_1.printTrailingComment)(path),
    ];
}
//# sourceMappingURL=printer.js.map