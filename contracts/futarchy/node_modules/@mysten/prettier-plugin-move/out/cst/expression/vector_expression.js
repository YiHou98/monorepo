"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.NODE_TYPE = void 0;
exports.default = default_1;
const prettier_1 = require("prettier");
const utilities_1 = require("../../utilities");
const block_1 = require("./block");
const { group, lineSuffix } = prettier_1.doc.builders;
/** The type of the node implemented in this file */
exports.NODE_TYPE = 'vector_expression';
function default_1(path) {
    if (path.node.type === exports.NODE_TYPE) {
        return printVectorExpression;
    }
    return null;
}
/**
 * Print `vector_expression` node.
 */
function printVectorExpression(path, options, print) {
    if (path.node.namedChildCount === 0) {
        return 'vector[]';
    }
    // Injected print callback for elements in the vector
    const printCb = (path) => printElement(path, options, print);
    const trailing = path.node.trailingComment;
    let trailingComment = '';
    if (trailing?.type === 'line_comment') {
        trailingComment = (0, utilities_1.printTrailingComment)(path, false);
        path.node.disableTrailingComment();
    }
    // Vector without type specified
    // Eg: `vector[....]`
    if (path.node.child(0)?.text == 'vector[') {
        return group([
            'vector',
            (0, utilities_1.list)({ path, print: printCb, options, open: '[', close: ']' }),
            lineSuffix(trailingComment),
        ], { shouldBreak: false });
    }
    if (!path.node.nonFormattingChildren[0]?.isTypeParam) {
        throw new Error(`Expected a type parameter in the \`vector_expression\`, got \`${path.node.nonFormattingChildren[0]?.type}\``);
    }
    if (path.node.nonFormattingChildren.slice(1).some((child) => child.isTypeParam)) {
        throw new Error('Expected only one type parameter in the `vector_expression`');
    }
    // Vector with type
    // Eg: `vector<TYPE>[...]`
    return [
        'vector<',
        // do not break the type in vector literal
        // indent(softline),
        group(path.call(print, 'nonFormattingChildren', 0), { shouldBreak: false }),
        '>',
        group((0, utilities_1.list)({
            path,
            print: printCb,
            options,
            open: '[',
            close: ']',
            skipChildren: 1,
            shouldBreak: false,
        })),
        lineSuffix(trailingComment),
    ];
}
/**
 * Special print elements in the `vector_expression`.
 *
 * - we want to use breakable blocks for `block` nodes;
 */
function printElement(path, options, print) {
    if (path.node.type === 'block') {
        return (0, block_1.printBreakableBlock)(path, options, print);
    }
    return print(path);
}
//# sourceMappingURL=vector_expression.js.map