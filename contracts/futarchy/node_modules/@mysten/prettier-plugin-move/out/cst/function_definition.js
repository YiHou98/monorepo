"use strict";
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionDefinition = void 0;
exports.default = default_1;
exports.printFunctionDefinition = printFunctionDefinition;
exports.printNativeFunctionDefinition = printNativeFunctionDefinition;
exports.printMacroFunctionDefinition = printMacroFunctionDefinition;
exports.printVisibilityModifier = printVisibilityModifier;
exports.printFunctionParameters = printFunctionParameters;
exports.printFunctionParameter = printFunctionParameter;
exports.printMutFunctionParameter = printMutFunctionParameter;
exports.printReturnType = printReturnType;
exports.printTypeArguments = printTypeArguments;
exports.printTypeParameters = printTypeParameters;
exports.printTypeParameter = printTypeParameter;
const prettier_1 = require("prettier");
const block_1 = require("./expression/block");
const utilities_1 = require("../utilities");
const { join, group } = prettier_1.doc.builders;
function default_1(path) {
    switch (path.node.type) {
        case FunctionDefinition.NativeFunctionDefinition:
            return printNativeFunctionDefinition;
        case FunctionDefinition.FunctionDefinition:
            return printFunctionDefinition;
        case FunctionDefinition.MacroFunctionDefinition:
            return printMacroFunctionDefinition;
        case FunctionDefinition.VisibilityModifier:
            return printVisibilityModifier;
        case FunctionDefinition.FunctionParameters:
            return printFunctionParameters;
        case FunctionDefinition.FunctionParameter:
            return printFunctionParameter;
        case FunctionDefinition.MutFunctionParameter:
            return printMutFunctionParameter;
        case FunctionDefinition.ReturnType:
            return printReturnType;
        case FunctionDefinition.TypeArguments:
            return printTypeArguments;
        case FunctionDefinition.TypeParameters:
            return printTypeParameters;
        case FunctionDefinition.TypeParameter:
            return printTypeParameter;
        // identifiers
        case FunctionDefinition.FunctionIdentifier:
        case FunctionDefinition.TypeParameterIdentifier:
            return utilities_1.printIdentifier;
    }
    return null;
}
/**
 * Function Definition, contains the following:
 * ```
 * <visibility> fun <identifier> (<parameters>) <return_type> <body>
 * ```
 */
var FunctionDefinition;
(function (FunctionDefinition) {
    FunctionDefinition["FunctionDefinition"] = "function_definition";
    FunctionDefinition["FunctionIdentifier"] = "function_identifier";
    FunctionDefinition["NativeFunctionDefinition"] = "native_function_definition";
    FunctionDefinition["MacroFunctionDefinition"] = "macro_function_definition";
    FunctionDefinition["VisibilityModifier"] = "visibility_modifier";
    FunctionDefinition["FunctionParameters"] = "function_parameters";
    FunctionDefinition["FunctionParameter"] = "function_parameter";
    FunctionDefinition["MutFunctionParameter"] = "mut_function_parameter";
    FunctionDefinition["ReturnType"] = "ret_type";
    FunctionDefinition["TypeArguments"] = "type_arguments";
    FunctionDefinition["TypeParameters"] = "type_parameters";
    FunctionDefinition["TypeParameter"] = "type_parameter";
    FunctionDefinition["TypeParameterIdentifier"] = "type_parameter_identifier";
})(FunctionDefinition || (exports.FunctionDefinition = FunctionDefinition = {}));
/**
 * Print `function_definition` node.
 */
function printFunctionDefinition(path, options, print) {
    const nodes = path.node.nonFormattingChildren;
    const retIndex = nodes.findIndex((e) => e.type == FunctionDefinition.ReturnType);
    const modifiers = getModifiers(path);
    const printCb = (path) => path.node.type === 'block' ? (0, block_1.printBreakableBlock)(path, options, print) : print(path);
    const signature = [
        printModifiers(modifiers),
        'fun ',
        path.map((path) => {
            // We already added modifiers in the previous step
            if (path.node.type == 'modifier')
                return '';
            if (path.node.type == 'block')
                return '';
            if (path.node.type == 'ret_type')
                return '';
            if (path.node.isFormatting)
                return '';
            return print(path);
        }, 'nonFormattingChildren'),
    ];
    return [
        group([signature, path.call(print, 'nonFormattingChildren', retIndex)]),
        ' ',
        path.call(printCb, 'nonFormattingChildren', nodes.length - 1),
    ];
}
function printNativeFunctionDefinition(path, _opt, print) {
    const modifiers = getModifiers(path);
    return [
        printModifiers(modifiers),
        'fun ',
        group(path.map((path) => {
            if (path.node.type == 'modifier')
                return '';
            return print(path);
        }, 'nonFormattingChildren')),
        ';',
    ];
}
/**
 * Print `macro_function_definition` node.
 */
function printMacroFunctionDefinition(path, _opt, print) {
    const modifiers = getModifiers(path);
    return [
        printModifiers(modifiers),
        'macro fun ',
        group(path.map((path) => {
            if (path.node.type == 'modifier')
                return '';
            if (path.node.type == 'block')
                return '';
            return print(path);
        }, 'nonFormattingChildren')),
        ' ',
        path.call(print, 'nonFormattingChildren', path.node.nonFormattingChildren.length - 1),
    ];
}
/**
 * Print `visibility_modifier` node.
 * Always followed by a space.
 */
function printVisibilityModifier(path, //  | Node | null,
_opt, _print) {
    return [path.node.text, ' '];
}
/**
 * Print `function_parameters` node.
 */
function printFunctionParameters(path, options, print) {
    return (0, utilities_1.list)({
        path,
        print,
        options,
        open: '(',
        close: ')',
        shouldBreak: false,
    });
}
/**
 * Print `function_parameter` node.
 */
function printFunctionParameter(path, _opt, print) {
    const isMut = path.node.child(0)?.type == 'mut';
    const isDollar = path.node.children.find((c) => c.type == '$');
    return group([
        isMut ? 'mut ' : '',
        isDollar ? '$' : '',
        path.call(print, 'nonFormattingChildren', 0), // variable_identifier
        ': ',
        path.call(print, 'nonFormattingChildren', 1), // type
    ]);
}
/**
 * Print `mut` function parameter.
 */
function printMutFunctionParameter(path, _opt, print) {
    return ['mut ', path.call(print, 'nonFormattingChildren', 0)];
}
/**
 * Print `ret_type` node.
 */
function printReturnType(path, _opt, print) {
    return [': ', path.call(print, 'nonFormattingChildren', 0)];
}
/**
 * Print `type_arguments` node.
 */
function printTypeArguments(path, options, print) {
    return group((0, utilities_1.list)({
        path,
        print,
        options,
        open: '<',
        close: '>',
        shouldBreak: false,
    }));
}
/**
 * Print `type_parameters` node.
 */
function printTypeParameters(path, options, print) {
    return group((0, utilities_1.list)({
        path,
        print,
        options,
        open: '<',
        close: '>',
        shouldBreak: false,
    }));
}
/**
 * Print `type_parameter` node.
 */
function printTypeParameter(path, _opt, print) {
    const isDollar = path.node.child(0)?.type == '$';
    const isPhantom = path.node.child(0)?.type == 'phantom';
    const parameter = path.call(print, 'nonFormattingChildren', 0);
    const abilities = path.map(print, 'nonFormattingChildren').slice(1);
    return [
        isDollar ? '$' : '',
        isPhantom ? 'phantom ' : '',
        parameter,
        abilities.length > 0 ? ': ' : '',
        join(' + ', abilities),
    ];
}
/**
 * Helper function to get modifiers.
 */
function getModifiers(path) {
    const nodes = path.node.nonFormattingChildren;
    return nodes
        .filter((e) => e.type == 'modifier')
        .map((e) => e.text.replace(' ', '')) // removes the space in `public (package)`
        .reduce((acc, e) => ({ ...acc, [e]: true }), {});
}
/**
 * Helper function to print modifiers.
 */
function printModifiers(modifiers) {
    return [
        modifiers.public ? 'public ' : '',
        modifiers['public(package)'] ? 'public(package) ' : '',
        modifiers['public(friend)'] ? 'public(friend) ' : '',
        modifiers.entry ? 'entry ' : '',
        modifiers.native ? 'native ' : '',
    ];
}
//# sourceMappingURL=function_definition.js.map